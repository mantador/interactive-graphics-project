{
  "version": 3,
  "sources": ["lib/constants.js", "lib/sphere.js", "lib/utils.js", "lib/computing.js", "lib/graphics.js", "lib/scenarios.js", "lib/box.js", "lib/main.js"],
  "sourcesContent": ["export class Constants {\n  static nBodies = 50;\n  static dt = 0.1; // approx of 1/60\n  static G = 0.05;\n  static log = false;\n  static defaultMinRadius = 10;\n  static defaultMaxRadius = 30;\n  static lightPosition = [300, 200, 1500];\n  static cameraPosition = [500, 500, 2000];\n  static cameraTarget = [500, 500, 500];\n}\n", "import { Constants } from \"./constants\";\n\n\nexport class Sphere {\n  verteces = [];\n  static DIV = 50;\n  static PI2 = Math.PI * 2;\n  static DRAD = Sphere.PI2 / Sphere.DIV;\n\n  constructor(conf) {\n    this.verteces = [];\n    this._center = conf.center;\n    this.mass = conf.mass;\n    this._velocity = conf.velocity;\n  }\n\n  get velocity() { return [this._velocity.x, this._velocity.y, this._velocity.z, 0]; }\n\n  get center() { return [this._center.x, this._center.y, this._center.z, this.mass ]; }\n\n  static randomPosition(r) {\n    return Math.floor(Math.random() * (1000 - 2 * r)) + r;\n  }\n\n  static random(minRadius = 10, maxRadius = 40) {\n    const r = Math.floor(Math.random() * (maxRadius - minRadius)) + minRadius;\n    // Ensure that position + radius does not overflow the canvas\n    let x = Sphere.randomPosition(r);\n    let y = Sphere.randomPosition(r);\n    let z = Sphere.randomPosition(r);\n    return new Sphere({\n      center: {\n        x: x,\n        y: y,\n        z: z,\n      },\n      velocity: {\n        x: 0,\n        y: 0,\n        z: 0,\n      }, \n      mass: r,\n    });\n  }\n}\n", "import { Constants } from \"./constants\";\n\nfunction createCShader(gl, source, type) {\n  var shader = gl.createShader(type);\n  if (shader == null) throw new DOMException(\"Compiled shader is null\");\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader;\n  }\n\n  console.error(gl.getShaderInfoLog(shader));\n  throw new Error(gl.getShaderInfoLog(shader) || \"No message available\");\n}\n\nexport function createWebglProgram(gl, sourceVS, sourceFS) {\n  const vertexShader = createCShader(gl, sourceVS, gl.VERTEX_SHADER);\n  const fragmentShader = createCShader(gl, sourceFS, gl.FRAGMENT_SHADER);\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program;\n  }\n\n  console.error(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n}\n\nexport function resizeCanvasToDisplaySize(canvas) {\n  // Lookup the size the browser is displaying the canvas in CSS pixels.\n  const displayWidth = canvas.clientWidth;\n  const displayHeight = canvas.clientHeight;\n\n  // Check if the canvas is not the same size.\n  const needResize =\n    canvas.width !== displayWidth || canvas.height !== displayHeight;\n\n  if (needResize) {\n    // Make the canvas the same size\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n\n  return needResize;\n}\n\nexport function checkGlExtensions(canvas) {\n\n  const gl = canvas.getContext(\"webgl\");\n  if (!gl) {\n    throw new Error(\"No webgl here\");\n  }\n\n  // check we can use floating point textures\n  const ext1 = gl.getExtension('OES_texture_float');\n  if (!ext1) {\n    throw ('Need OES_texture_float');\n  }\n  // check we can render to floating point textures\n  const ext2 = gl.getExtension('WEBGL_color_buffer_float');\n  if (!ext2) {\n    throw ('Need WEBGL_color_buffer_float');\n  }\n  // check we can use textures in a vertex shader\n  if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) < 1) {\n    throw ('Can not use textures in vertex shaders');\n  }\n\n  const ext = gl.getExtension('GMAN_debug_helper');\n\n}\n\nexport function initCanvas() {\n  const canvas = document.querySelector(\"#canvas\");\n  if (!canvas) {\n    throw new Error(\"Canvas not found\");\n  }\n  checkGlExtensions(canvas);\n  resizeCanvasToDisplaySize(canvas);\n  return canvas;\n}\n\nexport function MatrixStorage(gl) {\n  var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\n  var projectionMatrix = m4.perspective(60 * Math.PI / 180, aspect, 1, 3000);\n  var target = Constants.cameraTarget;\n  var up = [0, 1, 0];\n  return {\n    getMatrix: (rotx = 0, roty = 0) => {\n      // Avoid gimbal-lock effect\n      rotx = Math.max(-Math.PI / 2.1, Math.min(Math.PI / 2.1, rotx));\n      rotx = rotx % (2 * Math.PI);\n\n      var rotXMatrix = m4.xRotation(rotx);\n      var rotYMatrix = m4.yRotation(roty);\n\n      var cameraRotation = m4.multiply(rotYMatrix, rotXMatrix);\n      var c = Constants.cameraPosition;\n      var targetDiff = m4.subtractVectors(c, target);\n      var rotatedOffset = m4.transformVector(cameraRotation, [...targetDiff, 1]);\n      var cameraPosition = m4.addVectors(target, rotatedOffset);\n      c = [cameraPosition[0], cameraPosition[1], cameraPosition[2]];\n\n      var cameraMatrix = m4.lookAt(c, target, up, m4.identity());\n      var viewMatrix = m4.inverse(cameraMatrix);\n      var perspective = m4.multiply(projectionMatrix, viewMatrix)\n      return perspective;\n    }\n  };\n}", "import { Constants } from \"./constants\";\nimport { Sphere } from \"./sphere\";\nimport { checkGlExtensions, createWebglProgram } from \"./utils\";\n\nconst vsVelocities = /*glsl*/`\nattribute vec4 position;\nvoid main() {\n  gl_Position = position;\n}\n`;\n\n// ===============================\n\nconst fsVelocities = /*glsl*/`\nprecision mediump float;\n\nuniform sampler2D positionTexture;\nuniform sampler2D velocityTexture;\nuniform vec2 dimensions;\nuniform float DT;\nuniform float G;\n\nconst float MAX_ITER=1000.0;\n\nvec2 indexToTextureIndex(vec2 dimensions, float index) {\n  float y = floor(index / dimensions.x);\n  float x = mod(index, dimensions.x);\n  return (vec2(x, y) + 0.5) / dimensions;\n}\n\nvec3 reflectVelocity(vec3 vel, vec3 normal) {\n  float dotp = dot(vel.xyz, normal);\n  float norm = dot(normal, normal);\n  return vel.xyz - (2.0 * (dotp/norm) )*normal;\n}\n\nvec3 checkAndAdjustWallCollisions(vec4 pos, vec3 vel) {\n  if (pos.x >= 1000.0) {\n    vel = reflectVelocity(vel, vec3(-1, 0, 0));\n  }\n\n  if (pos.x <= 0.0) {\n    vel = reflectVelocity(vel, vec3(1, 0, 0));\n  }\n\n  if (pos.y >= 1000.0) { // Collision on upper plane\n    vel = reflectVelocity(vel, vec3(0, -1, 0));\n  }\n  if (pos.y <= 0.0) {\n    vel = reflectVelocity(vel, vec3(0, 1, 0));\n  }\n\n  if (pos.z >= 1000.0) {\n    vel = reflectVelocity(vel, vec3(0, 0, -1));\n  }\n\n  if (pos.z <= 0.0) {\n    vel = reflectVelocity(vel, vec3(0, 0, 1));\n  }\n\n  return vel;\n}\n\nvec3 calculateCollisionVelocity(vec4 p1, vec4 p2, vec3 v1, vec3 v2) {\n  // p1.w and p2.w represent both mass and radius\n  // For proper physics, mass should scale with volume (r\u00B3)\n  float m1 = p1.w * p1.w * p1.w;  // Mass of first sphere\n  float m2 = p2.w * p2.w * p2.w;  // Mass of second sphere\n  \n  // Calculate the collision normal\n  vec3 normal = normalize(p1.xyz - p2.xyz);\n  \n  // Calculate velocities along the normal\n  float v1n = dot(v1, normal);\n  float v2n = dot(v2, normal);\n  \n  // If spheres are moving apart, no collision needed\n  if (v1n - v2n > 0.0) {\n      return v1;\n  }\n  \n  // Calculate new velocity along normal using conservation of momentum\n  // and energy for a 1D collision\n  float newV1n = (m1 * v1n + m2 * v2n - m2 * (v1n - v2n)) / (m1 + m2);\n  \n  // Calculate the change in normal velocity\n  float deltaV1n = newV1n - v1n;\n  \n  // Apply the velocity change along the normal direction\n  // Keep the tangential velocity component unchanged\n  return v1 + deltaV1n * normal;\n}\n\n\nvec3 checkAndAdjustSphereCollisions(vec4 p1, vec3 v1) {\n  vec3 newVel = v1;\n  \n  for(float i = 0.0; i < MAX_ITER; i++) {\n      if (float(i) == floor(gl_FragCoord.x)) { continue; }\n      if (float(i) == dimensions.x) { break; }\n      \n      vec2 index = indexToTextureIndex(dimensions, float(i));\n      vec4 p2 = texture2D(positionTexture, index);\n      vec4 v2 = texture2D(velocityTexture, index);\n      \n      float distance = length(p1.xyz - p2.xyz);\n      float minDist = p1.w + p2.w;  // Sum of radii\n      \n      if (distance <= minDist) {\n          // Collision detected\n          newVel = calculateCollisionVelocity(p1, p2, newVel, v2.xyz);\n          \n          // Add separation vector to prevent spheres from sticking\n          vec3 separationNormal = normalize(p1.xyz - p2.xyz);\n          float overlap = minDist - distance;\n          newVel += separationNormal * overlap * 0.1; // Scale factor to prevent too strong separation\n      }\n  }\n  \n  return newVel;\n}\n\n\nvoid main() {\n  vec2 texcoord = gl_FragCoord.xy / dimensions;\n  vec4 p1 = texture2D(positionTexture, texcoord);\n  vec4 v = texture2D(velocityTexture, texcoord);  \n  \n  vec3 totalForce = vec3(0, 0, 0);\n  float m1 = pow(p1.w, 3.0);\n  \n  for(float i = 0.0; i < MAX_ITER; i++) {\n    if (float(i) == floor(gl_FragCoord.x)) { continue; }\n    if (float(i) == dimensions.x) { break; }\n    \n    vec2 index = indexToTextureIndex(dimensions, float(i));\n    \n    vec4 p2 = texture2D(positionTexture, index);\n    float m2 = pow(p2.w, 3.0);\n    vec3 diff = p2.xyz - p1.xyz;\n    float distanc = pow(length(diff), 3.0);\n    \n    vec3 force = G*( (m1 * m2) / (distanc) )*diff;\n\n    totalForce += force;\n  }\n  vec3 acc = totalForce/m1;\n  \n  vec3 deltaVel = acc*DT;\n  vec3 vel = v.xyz + deltaVel;\n  \n  vec3 newVel;\n  newVel = checkAndAdjustSphereCollisions(p1, vel);\n  newVel = checkAndAdjustWallCollisions(p1, newVel);\n  \n  gl_FragColor = vec4(newVel, 0);\n}\n`;\n\n// ===============================\n\nconst vsPositions = /*glsl*/`\nattribute vec4 position;\n\nvoid main() {\n  gl_Position = position;\n}\n`;\n\nconst fsPositions = /*glsl*/`\nprecision mediump float;\n\nuniform sampler2D positionTexture;\nuniform sampler2D velocityTexture;\nuniform vec2 dimensions;\nuniform float DT;\n\nvoid main() {\n  vec2 texcoord = gl_FragCoord.xy / dimensions;\n  vec4 positionValue = texture2D(positionTexture, texcoord);\n  vec4 velocityValue = texture2D(velocityTexture, texcoord);\n  gl_FragColor = positionValue + velocityValue*DT; // deltaT\n}\n`;\n\n\nexport function initComputingProgram(gl, spheres) {\n\n  const textureWidth = spheres.length;\n  const textureHeight = 1;\n\n  const ext = gl.getExtension('GMAN_debug_helper');\n\n  const velocityProgram = createWebglProgram(gl, vsVelocities, fsVelocities);\n  ext.tagObject(velocityProgram, 'velocity-computation-program');\n  const positionProgram = createWebglProgram(gl, vsPositions, fsPositions);\n  ext.tagObject(positionProgram, 'position-computation-program');\n\n  gl.useProgram(positionProgram);\n  const positionProgramLocs = {\n    position: gl.getAttribLocation(positionProgram, \"position\"),\n    positionTexture: gl.getUniformLocation(positionProgram, \"positionTexture\"),\n    velocityTexture: gl.getUniformLocation(positionProgram, \"velocityTexture\"),\n    dimensions: gl.getUniformLocation(positionProgram, \"dimensions\"),\n    dt: gl.getUniformLocation(positionProgram, \"DT\"),\n  }\n\n  const velocityProgramLocs = {\n    position: gl.getAttribLocation(velocityProgram, \"position\"),\n    positionTexture: gl.getUniformLocation(velocityProgram, \"positionTexture\"),\n    velocityTexture: gl.getUniformLocation(velocityProgram, \"velocityTexture\"),\n    dimensions: gl.getUniformLocation(velocityProgram, \"dimensions\"),\n    dt: gl.getUniformLocation(velocityProgram, \"DT\"),\n    G: gl.getUniformLocation(velocityProgram, \"G\"),\n  }\n\n  // setup a full canvas clip space quad\n  const spherePositions = new Float32Array(\n    spheres.map((sphere) => sphere.center).flat(),\n  );\n\n  const sphereVelocities = new Float32Array(\n    spheres.map((sphere) => sphere.velocity).flat()\n  )\n\n  const positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),\n    gl.STATIC_DRAW,\n  );\n\n  const inputPositionTex = createTexture(\n    gl,\n    spherePositions,\n    textureWidth,\n    textureHeight,\n  );\n  ext.tagObject(inputPositionTex, 'input-position-texture');\n  inputPositionTex.id = \"input-position-tex\";\n\n  const inputVelocityTex = createTexture(\n    gl,\n    sphereVelocities,\n    textureWidth,\n    textureHeight\n  )\n  ext.tagObject(inputVelocityTex, 'input-velocity-texture');\n  inputVelocityTex.id = \"input-velocity-tex\";\n\n\n  const outputPositionTex = createTexture(gl, null, textureWidth, textureHeight);\n  ext.tagObject(outputPositionTex, 'output-position-texture');\n  outputPositionTex.id = \"output-position-tex\";\n\n  const outputVelocityTex = createTexture(\n    gl,\n    sphereVelocities,\n    textureWidth,\n    textureHeight\n  )\n  ext.tagObject(outputVelocityTex, 'output-velocity-texture');\n  outputVelocityTex.id = \"output-velocity-tex\";\n\n  const inputPositionFb = createFramebuffer(gl, textureWidth, textureHeight, inputPositionTex);\n  ext.tagObject(inputPositionFb, 'input-position-framebuf');\n\n  const outputPositionFb = createFramebuffer(gl, textureWidth, textureHeight, outputPositionTex);\n  ext.tagObject(outputPositionFb, 'output-position-framebuf');\n  outputPositionFb.texture = outputPositionTex;\n\n  const inputVelocityFb = createFramebuffer(gl, textureWidth, textureHeight, inputVelocityTex);\n  ext.tagObject(inputVelocityFb, 'input-velocity-framebuf')\n\n  const outputVelocityFb = createFramebuffer(gl, textureWidth, textureHeight, outputVelocityTex);\n  ext.tagObject(outputVelocityFb, 'output-velocity-framebuf')\n\n\n  console.log(spherePositions)\n\n  let dataBuffers = [\n    {\n      velocity: { frameBuffer: outputVelocityFb, inputTexture: inputVelocityTex, outputTexture: outputVelocityTex },\n      position: { frameBuffer: outputPositionFb, inputTexture: inputPositionTex, outputTexture: outputPositionTex },\n    },\n    {\n      velocity: { frameBuffer: inputVelocityFb, inputTexture: outputVelocityTex, outputTexture: inputVelocityTex },\n      position: { frameBuffer: inputPositionFb, inputTexture: outputPositionTex, outputTexture: inputPositionTex },\n    },\n  ];\n\n  function computeVelocities(dataBuffer) {\n    gl.useProgram(velocityProgram);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, dataBuffer.position.inputTexture);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, dataBuffer.velocity.inputTexture);\n\n    gl.uniform1i(velocityProgramLocs.positionTexture, 0);\n    gl.uniform1i(velocityProgramLocs.velocityTexture, 1);\n    gl.uniform2f(velocityProgramLocs.dimensions, textureWidth, textureHeight)\n    gl.uniform1f(velocityProgramLocs.dt, Constants.dt);\n    gl.uniform1f(velocityProgramLocs.G, Constants.G);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, dataBuffer.velocity.frameBuffer);\n    gl.viewport(0, 0, textureWidth, textureHeight);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.enableVertexAttribArray(positionProgramLocs.position);\n    gl.vertexAttribPointer(\n      positionProgramLocs.position,\n      2, // size (num components)\n      gl.FLOAT, // type of data in buffer\n      false, // normalize\n      0, // stride (0 = auto)\n      0, // offset\n    );\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n    if (Constants.log) {\n      const results = new Float32Array(textureWidth * textureHeight * 4);\n      gl.readPixels(\n        0,\n        0,\n        textureWidth,\n        textureHeight,\n        gl.RGBA,\n        gl.FLOAT,\n        results,\n      );\n      // print the results\n      console.log('VELOCITIES');\n      console.log(results);\n    }\n  }\n\n  function computePositions(dataBuffer) {\n    gl.useProgram(positionProgram);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, dataBuffer.position.inputTexture);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, dataBuffer.velocity.outputTexture);\n\n    gl.uniform1i(positionProgramLocs.positionTexture, 0);\n    gl.uniform1i(positionProgramLocs.velocityTexture, 1);\n    gl.uniform2f(positionProgramLocs.dimensions, textureWidth, textureHeight);\n    gl.uniform1f(positionProgramLocs.dt, Constants.dt);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, dataBuffer.position.frameBuffer);\n    gl.viewport(0, 0, textureWidth, textureHeight);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.enableVertexAttribArray(positionProgramLocs.position);\n    gl.vertexAttribPointer(\n      positionProgramLocs.position,\n      2, // size (num components)\n      gl.FLOAT, // type of data in buffer\n      false, // normalize\n      0, // stride (0 = auto)\n      0, // offset\n    );\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    // get the result\n\n    if (Constants.log) {\n      const results = new Float32Array(textureWidth * textureHeight * 4);\n      gl.readPixels(\n        0,\n        0,\n        textureWidth,\n        textureHeight,\n        gl.RGBA,\n        gl.FLOAT,\n        results,\n      );\n      // print the results\n      console.log(\"POSITIONS\")\n      console.log(results);\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n  }\n\n  return {\n    dataBuffers,\n    computeVelocities,\n    computePositions,\n  };\n}\n\nfunction createTexture(gl, data, width, height) {\n  const tex = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  gl.pixelStorei(gl.PACK_ALIGNMENT, 1);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0, // mip level\n    gl.RGBA, // internal format\n    width,\n    height,\n    0, // border\n    gl.RGBA, // format\n    gl.FLOAT, // type\n    data,\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  return tex;\n}\n\nfunction createFramebuffer(gl, width, height, tex) {\n  const fb = gl.createFramebuffer();\n  gl.viewport(0, 0, width, height);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fb)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    tex,\n    0,\n  );\n  return fb;\n}\n", "import { Constants } from \"./constants\";\nimport { Sphere } from \"./sphere\";\nimport { createWebglProgram } from \"./utils\";\n\n\nexport function initGraphicsProgram(\n  gl,\n  spheres,\n) {\n  const vs = /*glsl*/`\n  const mediump float;\n  attribute float index;\n  uniform sampler2D positionTexture;\n  uniform vec2 dimensions;\n  uniform mat4 matrix;\n  uniform vec3 cameraPosition;\n  \n  varying vec3 vPos;\n  varying float vRad;\n  varying vec3 cameraPos;\n  \n  vec2 indexToTextureIndex(vec2 dimensions, float index) {\n    float y = floor(index / dimensions.x);\n    float x = mod(index, dimensions.x);\n    return (vec2(x, y) + 0.5) / dimensions;\n  }\n\n  void main() {\n    vec4 position = texture2D(positionTexture, indexToTextureIndex(dimensions, index));\n    vPos = position.xyz;\n    vRad = position.w;\n    cameraPos = cameraPosition;\n    \n    gl_Position = matrix*vec4(position.xyz, 1.0);\n    vec4 viewSpace = vec4(position.xyz - cameraPosition, 1.0);\n    float distanceFromCamera = length(viewSpace.xyz);\n    \n    float perspectiveScale = 1000.0 / distanceFromCamera;\n    gl_PointSize = position.w * perspectiveScale;\n  }\n  `;\n  \n  const fs = /*glsl*/`\n  precision mediump float;\n\n  varying vec3 vPos;\n  varying float vRad;\n  varying vec3 cameraPos;\n  \n  uniform vec3 lightPos;\n\n  void main() {\n    vec2 centerToPixel = 2.0 * gl_PointCoord - 1.0;\n    float r_2 = dot(centerToPixel, centerToPixel);\n    \n    if (r_2 > 1.0) {\n        discard;\n      }\n      \n    float z = sqrt(1.0 - r_2);\n    vec3 normal = normalize(vec3(centerToPixel.x, -centerToPixel.y, z));\n\n    vec3 fragPos = vPos + vRad * normal;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 viewDir = normalize(cameraPos - fragPos);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    \n    float ambient = 0.2;\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    \n    float spec = pow(max(dot(normal, halfDir), 0.0), 2.0);\n    \n    vec3 sphereColor = vec3(1.0, 1.0, 1.0);\n    vec3 finalColor = sphereColor * (ambient + diff + 0.5 * spec);\n\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n  `;\n\n  const program = createWebglProgram(gl, vs, fs);\n  gl.useProgram(program);\n\n  const indexLoc = gl.getAttribLocation(program, \"index\");\n  const textureLoc = gl.getUniformLocation(program, \"positionTexture\");\n  const dimensionsLoc = gl.getUniformLocation(program, \"dimensions\");\n  const matrixLoc = gl.getUniformLocation(program, \"matrix\");\n  const cameraLoc = gl.getUniformLocation(program, \"cameraPosition\");\n  const lightLoc = gl.getUniformLocation(program, \"lightPos\");\n\n  gl.uniform1i(textureLoc, 0);\n  gl.uniform2f(dimensionsLoc, spheres.length, 1);\n  const lightPosition = Constants.lightPosition;\n  gl.uniform3f(lightLoc, lightPosition[0], lightPosition[1], lightPosition[2]);\n\n  if (gl.canvas instanceof OffscreenCanvas) {\n    throw new Error(\"Nope...\")\n  }\n\n  const cameraPosition = Constants.cameraPosition;\n  gl.uniform3f(cameraLoc, cameraPosition[0], cameraPosition[1], cameraPosition[2]);\n  const pBuffer = gl.createBuffer();\n  \n  \n  let ids = new Array(spheres.length).fill(0).map((_, i) => i);\n  gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(ids),\n    gl.STATIC_DRAW,\n  );\n  \n  return {\n    render: (dataBuffer, matrix) => {\n      gl.useProgram(program);\n      gl.uniformMatrix4fv(\n        matrixLoc, false,\n        matrix\n      )\n      gl.enable(gl.DEPTH_TEST);\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      \n      gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);\n      gl.enableVertexAttribArray(indexLoc);\n      gl.vertexAttribPointer(indexLoc, 1, gl.FLOAT, false, 0, 0);\n\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, dataBuffer.position.outputTexture);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\n\n      gl.drawArrays(gl.POINTS, 0, ids.length);\n    },\n  };\n}\n", "import { Constants } from \"./constants\";\nimport { Sphere } from \"./sphere\";\n\nexport const Scenarios = {\n    twoSpheresFacing: () => [\n        new Sphere({ center: { x: 200, y: 300, z: 500 }, velocity: { x: 3, y: 3, z: 0 }, mass: 20 }),\n        new Sphere({ center: { x: 800, y: 300, z: 500 }, velocity: { x: -3, y: 0, z: 0 }, mass: 80 }),\n    ],\n    random: (m, M, count) => {\n        const spheres = [];\n        for (let i = 0; i < count; i++) {\n            spheres.push(Sphere.random(m, M));\n        }\n        return spheres;\n    }\n};\n", "import { createWebglProgram } from \"./utils\";\n\nexport class BoxDrawer {\n\n\tconstructor(gl) {\n\t\tthis.gl = gl;\n\n\t\tthis.prog = createWebglProgram(gl, boxVS, boxFS);\n\n\t\tthis.mvp = gl.getUniformLocation(this.prog, 'mvp');\n\n\t\tthis.vertPos = gl.getAttribLocation(this.prog, 'pos');\n\n\t\tthis.vertbuffer = gl.createBuffer();\n\t\tvar pos = [\n\t\t\t0, 0, 0,\n\t\t\t0, 0, 1000,\n\t\t\t0, 1000, 0,\n\t\t\t0, 1000, 1000,\n\t\t\t1000, 0, 0,\n\t\t\t1000, 0, 1000,\n\t\t\t1000, 1000, 0,\n\t\t\t1000, 1000, 1000];\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);\n\n\t\tthis.linebuffer = gl.createBuffer();\n\t\tvar line = [\n\t\t\t0, 1, 1, 3, 3, 2, 2, 0,\n\t\t\t4, 5, 5, 7, 7, 6, 6, 4,\n\t\t\t0, 4, 1, 5, 3, 7, 2, 6];\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.linebuffer);\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(line), gl.STATIC_DRAW);\n\t}\n\tdraw(trans) {\n\t\t// Draw the line segments\n\t\tthis.gl.useProgram(this.prog);\n\t\tthis.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n\t\tthis.gl.enable(this.gl.DEPTH_TEST);\n\t\tthis.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n\t\t// this.gl.clearColor(0, 0, 0, 1);\n\t\t// this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n\t\tthis.gl.uniformMatrix4fv(this.mvp, false, trans);\n\t\tthis.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertbuffer);\n\t\tthis.gl.vertexAttribPointer(this.vertPos, 3, this.gl.FLOAT, false, 0, 0);\n\t\tthis.gl.enableVertexAttribArray(this.vertPos);\n\t\tthis.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.linebuffer);\n\t\tthis.gl.drawElements(this.gl.LINES, 24, this.gl.UNSIGNED_BYTE, 0);\n\t}\n}\n// Vertex shader source code\nvar boxVS = `\n\tattribute vec3 pos;\n\tuniform mat4 mvp;\n\tvoid main()\n\t{\n\t\tgl_Position = mvp * vec4(pos,1);\n\t}\n`;\n// Fragment shader source code\nvar boxFS = `\n\tprecision mediump float;\n\tvoid main()\n\t{\n\t\tgl_FragColor = vec4(1,1,1,1);\n\t}\n`;\n\nfunction MatrixMult(A, B) {\n\tvar C = [];\n\tfor (var i = 0; i < 4; ++i) {\n\t\tfor (var j = 0; j < 4; ++j) {\n\t\t\tvar v = 0;\n\t\t\tfor (var k = 0; k < 4; ++k) {\n\t\t\t\tv += A[j + 4 * k] * B[k + 4 * i];\n\t\t\t}\n\t\t\tC.push(v);\n\t\t}\n\t}\n\treturn C;\n}\n\nfunction GetModelViewMatrix(translationX, translationY, translationZ, rotationX, rotationY) {\n\tconst sX = Math.sin(rotationX);\n\tconst cX = Math.cos(rotationX);\n\tconst sY = Math.sin(rotationY);\n\tconst cY = Math.cos(rotationY);\n\n\tconst rotX = [\n\t\t1, 0, 0, 0,\n\t\t0, cX, sX, 0,\n\t\t0, -sX, cX, 0,\n\t\t0, 0, 0, 1,\n\t];\n\n\tconst rotY = [\n\t\tcY, 0, -sY, 0,\n\t\t0, 1, 0, 0,\n\t\tsY, 0, cY, 0,\n\t\ttranslationX, translationY, translationZ, 1,\n\t];\n\n\tconst tot = MatrixMult(rotY, rotX);\n\treturn tot;\n}\n", "import { initComputingProgram } from \"./computing\";\nimport { Constants } from \"./constants\";\nimport { initGraphicsProgram as initRenderingProgram } from \"./graphics\";\nimport { Sphere } from \"./sphere\";\nimport { initCanvas } from \"./utils\";\nimport { Scenarios } from \"./scenarios\";\nimport { BoxDrawer } from \"./box\";\nimport { MatrixStorage } from \"./utils\"\n\nfunction main(spheres) {\n  const canvas = initCanvas();\n\n  const gl = canvas.getContext(\"webgl\");\n  if (!gl) throw new Error(\"WebGL not enabled!\");\n\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n\n  const counter = new Counter()\n  const matrixStorage = MatrixStorage(gl);\n  const compute = initComputingProgram(gl, spheres);\n  const render = initRenderingProgram(gl, spheres);\n  const box = new BoxDrawer(gl)\n\n  var rotx = 0, roty = 0;\n\n  function renderStep() {\n    const matrix = matrixStorage.getMatrix(rotx, roty);\n    compute.computeVelocities(compute.dataBuffers[counter.count])\n    compute.computePositions(compute.dataBuffers[counter.count]);\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    box.draw(matrix)\n    render.render(compute.dataBuffers[counter.count], matrix)\n    counter.inc();\n    requestAnimationFrame(renderStep);\n  }\n  requestAnimationFrame(renderStep);\n\n\n  canvas.onmousedown = function (event) {\n    var cx = event.clientX;\n    var cy = event.clientY;\n    console.log(cx);\n\n    canvas.onmousemove = function (event) {\n      roty += (cx - event.clientX) / canvas.width * 5;\n      rotx += (cy - event.clientY) / canvas.height * 5;\n      cx = event.clientX;\n      cy = event.clientY;\n    }\n  }\n  canvas.onmouseup = canvas.onmouseleave = function () {\n    canvas.onmousemove = null;\n  }\n}\n\nfunction Counter() {\n  this.count = 0;\n  this.inc = () => (this.count = (this.count + 1) % 2);\n}\n\n\n\nconst minRadiusInput = document.getElementById('minRadius');\nconst maxRadiusInput = document.getElementById('maxRadius');\nconst nbodies = document.getElementById('number');\n\n\ndocument.getElementById('twospheres')\n  .addEventListener('click', () => main(Scenarios.twoSpheresFacing()))\ndocument.getElementById('random')\n  .addEventListener('click', () => main(Scenarios.random(Number(minRadiusInput.value), Number(maxRadiusInput.value), Number(nbodies.value))))\nwindow.addEventListener('load', () => main(Scenarios.random(Number(minRadiusInput.value), Number(maxRadiusInput.value), Number(nbodies.value))))"],
  "mappings": "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",
  "names": ["event"]
}
